---
layout: js
title: It's Me!
extra_js:
- assets/js/three.min.js
- assets/js/OrbitControls.js
- assets/js/GLTFLoader.js
- assets/js/perlin.js
---
<script id="vertexShader" type="x-shader/x-vertex">
  varying vec3 vNormal;
  varying vec3 vViewPosition;
  uniform float timeDelta;
  uniform sampler2D map;
  void main() {
    vec3 center = vec3(0.0, 0.0, 0.0);
    vec3 p = position;
    float distance = length(center - p);
    p += sin(distance + timeDelta/1000.0)*0.5;
    vec4 modelViewPosition = modelViewMatrix * vec4(p, 1.0);
    vViewPosition = -modelViewPosition.xyz;
    gl_Position = projectionMatrix * modelViewPosition;
    vNormal = normalMatrix * normal;
  }
</script>

<script>

  var renderer, scene, camera, controls, light;

  var newMaterial, test;
  var materialShader;

  init();

  function init(){

    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );

    renderer = new THREE.WebGLRenderer();
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );

    light = new THREE.HemisphereLight( 0xffffff, 0x444422, 1);
    light.position.set( 0, 1, 0 );
    scene.add( light );

    

    var uniforms = ({
      timeDelta : {type: 'f', value: 0},
      map: {type: 't', value: texture}
    });

    var phongShader = THREE.ShaderLib.phong;
    var mUniforms = THREE.UniformsUtils.merge([phongShader.uniforms, uniforms]);

    //This did not work!
    // newMaterial = new THREE.ShaderMaterial ({
    //   uniforms : mUniforms,
    //   vertexShader: document.getElementById( 'vertexShader' ).textContent,
    //   fragmentShader: phongShader.fragmentShader,
    //   lights: true,
    //   side : THREE.DoubleSide
    // });

    // var texture = new THREE.TextureLoader().load( "assets/textures/NewTexture.jpg", function ( texture ) {
    //   newMaterial.uniforms.map = texture;
    //   newMaterial.needsUpdate = true;
    // });

    // newMaterial.uniforms.map = texture;

    var test = new THREE.MeshPhongMaterial({map: texture})
    test.onBeforeCompile = function ( shader ) {

      // console.log( shader )

      shader.uniforms.time = { value: 0 };

      shader.vertexShader = 'uniform float time;\n' + shader.vertexShader;
      shader.vertexShader = shader.vertexShader.replace(
        '#include <begin_vertex>',
        [
          'float theta = sin( time + position.y ) / 2.0;',
          'float c = cos( theta );',
          'float s = sin( theta );',
          'mat3 m = mat3( c, 0, s, 0, 1, 0, -s, 0, c );',
          'vec3 transformed = vec3( position ) * m;',
          'vNormal = vNormal * m;'
        ].join( '\n' )
      );

      materialShader = shader;

    };

    var cube = new THREE.Mesh( cubeGeo, test );
    scene.add( cube );

    // model
    var loader = new THREE.GLTFLoader().setPath( 'assets/models/' );
    loader.load( 'luc_lowpoly.glb', function ( gltf ) {

      gltf.scene.traverse( function ( child ) {
        if ( child.isMesh ) {
          child.material = test;
        }
      } );

      scene.add( gltf.scene );
    }, undefined, function ( e ) {
      console.error( e );
    } );

    controls = new THREE.OrbitControls( camera );

    camera.position.z = 50;
    controls.update();

    window.addEventListener( 'resize', onWindowResize, false );
  }

  var startTime = Date.now();
  var timeDelta = 0;

  var animate = function () {
    //newMaterial.uniforms.timeDelta.value = timeDelta;

    requestAnimationFrame( animate );
    render();
    controls.update();
  };

  function render() {

    if ( materialShader ) {
      materialShader.uniforms.time.value = performance.now() / 1000;
    }
    renderer.render( scene, camera );

  }

  animate();

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize( window.innerWidth, window.innerHeight );
  }
</script>